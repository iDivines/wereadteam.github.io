<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="WeRead团队博客">
<meta property="og:url" content="http://wereadteam.github.io/index.html">
<meta property="og:site_name" content="WeRead团队博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WeRead团队博客">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> WeRead团队博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">WeRead团队博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/19/iOS-Component/" itemprop="url">
                  iOS 组件化探索
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-19T10:03:29+08:00" content="2016-03-19">
              2016-03-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <!--span class="post-meta-item-text">分类于</span-->
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <!--a href="/categories/bang/" itemprop="url" rel="index"-->
                    <span itemprop="name">bang</span>
                  <!--/a-->
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/19/iOS-Component/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/03/19/iOS-Component/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看了 Limboy(<a href="http://limboy.me/ios/2016/03/10/mgj-components.html" target="_blank" rel="external">文章1</a> <a href="http://limboy.me/ios/2016/03/14/mgj-components-continued.html" target="_blank" rel="external">文章2</a>) 和 Casa (<a href="http://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">文章</a>) 对 iOS 组件化方案的讨论，写篇文章梳理下思路。</p>
<p>首先我觉得”组件”在这里不太合适，因为按我理解组件是指比较小的功能块，这些组件不需要多少组件间通信，没什么依赖，也就不需要做什么其他处理，面向对象就能搞定。而这里提到的是较大粒度的业务功能，我们习惯称为”模块”。为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。</p>
<p>一个 APP 有多个模块，模块之间会通信，互相调用，例如微信读书有 书籍详情  想法列表  阅读器  发现卡片  等等模块，这些模块会互相调用，例如 书籍详情要调起阅读器和想法列表，阅读器要调起想法列表和书籍详情，等等，一般我们是怎样调用呢，以阅读器为例，会这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#34;WRBookDetailViewController.h&#34;&#10;#import &#34;WRReviewViewController.h&#34;&#10;@implementation Mediator&#10;+ (void)gotoDetail &#123;&#10;    WRBookDetailViewController *detailVC = [[WRBookDetailViewController alloc] initWithBookId:self.bookId];&#10;    [self.navigationController.pushViewController:detailVC animated:YES];&#10;&#125;&#10;&#10;+ (void)gotoReview &#123;&#10;    WRReviewViewController *reviewVC = [[WRReviewViewController alloc] initWithBookId:self.bookId reviewType:1];&#10;    [self.navigationController.pushViewController:reviewVC animated:YES];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？显而易见，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：</p>
<p><img src="/./img/component1.png" alt=""></p>
<p>这样揉成一坨对测试/编译/开发效率/后续扩展都有一些坏处，那怎么解开这一坨呢。很简单，按软件工程的思路，下意识就会加一个中间层：</p>
<p><img src="/./img/component2.png" alt=""></p>
<p>叫他 Mediator Manager Router 什么都行，反正就是负责转发信息的中间层，暂且叫他 Mediator。</p>
<p>看起来顺眼多了，但这里有几个问题：</p>
<ol>
<li>Mediator 怎么去转发组件间调用？</li>
<li>一个模块只跟 Mediator 通信，怎么知道另一个模块提供了什么接口？</li>
<li>按上图的画法，模块和 Mediator 间互相依赖，怎样破除这个依赖？</li>
</ol>
<h2 id="u65B9_u68481"><a href="#u65B9_u68481" class="headerlink" title="方案1"></a>方案1</h2><p>对于前两个问题，最直接的反应就是在 Mediator 直接提供接口，调用对应模块的方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Mediator.m&#10;#import &#34;BookDetailComponent.h&#34;&#10;#import &#34;ReviewComponent.h&#34;&#10;@implementation Mediator&#10;+ (UIViewController *)BookDetailComponent_viewController:(NSString *)bookId &#123;&#10;    return [BookDetailComponent detailViewController:bookId];&#10;&#125;&#10;+ (UIViewController *)ReviewComponent_viewController:(NSString *)bookId reviewType:(NSInteger)type &#123;&#10;    return [ReviewComponent reviewViewController:bookId type:type];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//BookDetailComponent  &#32452;&#20214;&#10;#import &#34;Mediator.h&#34;&#10;#import &#34;WRBookDetailViewController.h&#34;&#10;@implementation BookDetailComponent&#10;+ (UIViewController *)detailViewController:(NSString *)bookId &#123;&#10;    WRBookDetailViewController *detailVC = [[WRBookDetailViewController alloc] initWithBookId:bookId];&#10;    return detailVC;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ReviewComponent  &#32452;&#20214;&#10;#import &#34;Mediator.h&#34;&#10;#import &#34;WRReviewViewController.h&#34;&#10;@implementation ReviewComponent&#10;+ (UIViewController *)reviewViewController:(NSString *)bookId type:(NSInteger)type &#123;&#10;    UIViewController *reviewVC = [[WRReviewViewController alloc] initWithBookId:bookId type:type];&#10;    return reviewVC;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>然后在阅读模块里：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//WRReadingViewController.m&#10;#import &#34;Mediator.h&#34;&#10;@implementation WRReadingViewController&#10;+ (void)gotoDetail:(NSString *)bookId &#123;&#10;    UIViewController *detailVC = [Mediator BookDetailComponent_viewControllerForDetail:bookId];&#10;    [self.navigationController pushViewController:detailVC];&#10;&#10;    UIViewController *reviewVC = [Mediator ReviewComponent_viewController:bookId type:1];&#10;    [self.navigationController pushViewController:reviewVC];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>这就是一开始架构图的实现，看起来显然这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。</p>
<p>那怎么办呢。</p>
<p>怎样让Mediator解除对各个组件的依赖，同时又能调到各个组件暴露出来的方法？对于OC有一个法宝可以做到，就是runtime反射调用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Mediator.m&#10;@implementation Mediator&#10;+ (UIViewController *)BookDetailComponent_viewController:(NSString *)bookId &#123;&#10;    Class cls = NSClassFromString(@&#34;BookDetailComponent&#34;);&#10;    id obj = [[cls alloc] init];&#10;    return [obj performSelector:NSSelectorFromString(@&#34;detailViewController:&#34;) withObject:@&#123;@&#34;bookId&#34;:bookId&#125;];&#10;&#125;&#10;+ (UIViewController *)ReviewComponent_viewController:(NSString *)bookId type:(NSInteger)type &#123;&#10;    Class cls = NSClassFromString(@&#34;ReviewComponent&#34;);&#10;    id obj = [[cls alloc] init];&#10;    return [obj performSelector:NSSelectorFromString(@&#34;reviewViewController:&#34;) withObject:@&#123;@&#34;bookId&#34;:bookId, @&#34;type&#34;: @(type)&#125;];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>这下 Mediator 没有再对各个组件有依赖了，你看已经不需要 #import 什么东西了，对应的架构图就变成：</p>
<p><img src="/./img/component3.png" alt=""></p>
<p>只有调用其他组件接口时才需要依赖 Mediator，组件开发者不需要知道 Mediator 的存在。</p>
<p>等等，既然用runtime就可以解耦取消依赖，那还要Mediator做什么？组件间调用时直接用runtime接口调不就行了，这样就可以没有任何依赖就完成调用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//WRReadingViewController.m&#10;@implementation WRReadingViewController&#10;+ (void)gotoReview:(NSString *)bookId &#123;&#10;    Class cls = NSClassFromString(@&#34;BookDetailComponent&#34;);&#10;    id obj = [[cls alloc] init];&#10;    UIViewController *reviewVC = [obj performSelector:NSSelectorFromString(@&#34;reviewViewController:&#34;) withObject:@&#123;@&#34;bookId&#34;:bookId, @&#34;type&#34;: @(1)&#125;];&#10;    [self.navigationController pushViewController:reviewVC];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>这样就完全解耦了，但这样做的问题是：</p>
<ol>
<li>调用者写起来很恶心，代码提示都没有，每次调用写一坨。</li>
<li>runtime方法的参数个数和类型限制，导致只能每个接口都统一传一个 <code>NSDictionary</code>。这个 <code>NSDictionary</code>里的key value是什么不明确，需要找个地方写文档说明和查看。</li>
<li>编译器层面不依赖其他组件，实际上还是依赖了，直接在这里调用，没有引入调用的组件时就挂了</li>
</ol>
<p>把它移到Mediator后：</p>
<ol>
<li>调用者写起来不恶心，代码提示也有了。</li>
<li>参数类型和个数无限制，由 Mediator 去转就行了，组件提供的还是一个 <code>NSDictionary</code> 参数的接口，但在Mediator 里可以提供任意类型和个数的参数，像上面的例子显式要求参数 <code>NSString *bookId</code> 和 <code>NSInteger type</code>。</li>
<li>Mediator可以做统一处理，调用某个组件方法时如果某个组件不存在，可以做相应操作，让调用者与组件间没有耦合。</li>
</ol>
<p>到这里，基本上能解决我们的问题：各组件互不依赖，组件间调用只依赖中间件Mediator，Mediator不依赖其他组件。接下来就是优化这套写法，有两个优化点：</p>
<ol>
<li>Mediator 每一个方法里都要写 runtime 方法，格式是确定的，这是可以抽取出来的。</li>
<li>每个组件对外方法都要在 Mediator 写一遍，组件一多 Mediator 类的长度是恐怖的。</li>
</ol>
<p>优化后就成了 casa 的方案，target-action 对应第一点，target就是class，action就是selector，通过一些规则简化动态调用。Category 对应第二点，每个组件写一个 Mediator 的 Category，让 Mediator 不至于太长。这里有个<a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">demo</a>。</p>
<p>总结起来就是，组件通过中间件通信，中间件通过 runtime 接口解耦，通过 target-action 简化写法，通过 category 感官上分离组件接口代码。这里可以看到这个实现的 <a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">Demo</a>。</p>
<h2 id="u65B9_u68482"><a href="#u65B9_u68482" class="headerlink" title="方案2"></a>方案2</h2><p>回到 Mediator 最初的三个问题，蘑菇街用的是另一种方式解决：注册表的方式，用URL表示接口，在模块启动时注册模块提供的接口，一个简化的实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Mediator.m  &#20013;&#38388;&#20214;&#10;@implementation Mediator&#10;typedef void (^componentBlock) (UIAlertView *alertView);&#10;@property (nonatomic, storng) NSMutableDictionary *cache&#10;- (void)registerURLPattern:(NSString *)urlPattern toHandler:(componentBlock)blk &#123;&#10;    [cache setObject:blk forKey:urlPattern];&#10;&#125;&#10;&#10;- (void)openURL:(NSString *)url withParam:(id)param &#123;&#10;   componentBlock blk = [cache objectForKey:url];&#10;   if (bulk) blk(param);&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//BookDetailComponent  &#32452;&#20214;&#10;#import &#34;Mediator.h&#34;&#10;#import &#34;WRBookDetailViewController.h&#34;&#10;+ (void)initComponent &#123;&#10;   [[Mediator sharedInstance] registerURLPattern:@&#34;weread://bookDetail&#34; toHandler:^(NSDictionary *param) &#123;&#10;    WRBookDetailViewController *detailVC = [[WRBookDetailViewController alloc] initWithBookId:param[@&#34;bookId&#34;]];&#10;    [self.navigationController.pushViewController:detailVC animated:YES];&#10;   &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//WRReadingViewController.m  &#35843;&#29992;&#32773;&#10;//ReadingViewController.m&#10;#import &#34;Mediator.h&#34;&#10;&#10;+ (void)gotoDetail:(NSString *)bookId &#123;&#10;    [[Mediator sharedInstance] openURL:@&#34;weread://bookDetail&#34; withParam:@&#123;@&#34;bookId&#34;: bookId&#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这样同样做到每个模块间没有依赖，Mediator 也不依赖其他组件，不过这里不一样的一点是组件本身和调用者都依赖了Mediator，不过这不是重点，架构图还是跟方案1一样。</p>
<p>各个组件初始化时向 Mediator 注册对外提供的接口，Mediator 通过保存在内存的表去知道有哪些模块哪些接口，接口的形式是 <code>URL-&gt;block</code>。</p>
<p>这里抛开URL的远程调用和本地调用混在一起导致的问题，先说只用于本地调用的情况，对于本地调用，URL只是一个表示组件的key，没有其他作用，这样做有三个问题：</p>
<ol>
<li>需要有个地方列出各个组件里有什么 URL 接口可供调用。蘑菇街做了个后台专门管理。</li>
<li>每个组件都需要初始化，内存里需要保存一份表，组件多了会有内存问题。</li>
<li>参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式。</li>
</ol>
<p>第二点没法解决，第一点和第三点可以跟前面那个方案一样，在 Mediator 每个组件暴露方法的转接口，然后使用起来就跟前面那种方式一样了。</p>
<p>抛开URL不说，这种方案跟方案1的共同思路就是：Mediator 不能直接去调用组件的方法，因为这样会产生依赖，那我就要通过其他方法去调用，也就是通过 字符串-&gt;方法 的映射去调用。runtime 接口的 <code>className + selectorName -&gt; IMP</code> 是一种，注册表的 <code>key -&gt; block</code> 是一种，而前一种是 OC 自带的特性，后一种需要内存维持一份注册表，这是不必要的。</p>
<p>现在说回 URL，组件化是不应该跟 URL 扯上关系的，因为组件对外提供的接口主要是模块间代码层面上的调用，我们先称为本地调用，而 URL 主要用于 APP 间通信，姑且称为远程调用。按常规思路者应该是对于远程调用，再加个中间层转发到本地调用，让这两者分开。那这里这两者混在一起有什么问题呢？</p>
<p>如果是 URL 的形式，那组件对外提供接口时就要同时考虑本地调用和远程调用两种情况，而远程调用有个限制，传递的参数类型有限制，只能传能被字符串化的数据，或者说只能传能被转成 json 的数据，像 UIImage 这类对象是不行的，所以如果组件接口要考虑远程调用，这里的参数就不能是这类非常规对象，接口的定义就受限了。</p>
<p>用理论的话来说就是，远程调用是本地调用的子集，这里混在一起导致组件只能提供子集功能，无法提供像方案1那样提供全集功能。所以这个方案是天生有缺陷的，对于遗漏的这部分功能，蘑菇街使用了另一种方案补全，请看方案3。</p>
<h2 id="u65B9_u68483"><a href="#u65B9_u68483" class="headerlink" title="方案3"></a>方案3</h2><p>蘑菇街为了补全本地调用的功能，为组件多加了另一种方案，就是通过 protocol-class 注册表的方式。首先有一个新的中间件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ProtocolMediator.m  &#26032;&#20013;&#38388;&#20214;&#10;@implementation ProtocolMediator&#10;@property (nonatomic, storng) NSMutableDictionary *protocolCache&#10;- (void)registerProtocol:(Protocol *)proto forClass:(Class)cls &#123;&#10;    NSMutableDictionary *protocolCache;&#10;    [protocolCache setObject:cls forKey:NSStringFromProtocol(proto)];&#10;&#125;&#10;&#10;- (Class)classForProtocol:(Protocol *)proto &#123;&#10;  return protocolCache[NSStringFromProtocol(proto)];&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>然后有一个公共Protocol文件，定义了每一个组件对外提供的接口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//ComponentProtocol.h&#10;@protocol BookDetailComponentProtocol &#60;NSObject&#62;&#10;- (UIViewController *)bookDetailController:(NSString *)bookId;&#10;- (UIImage *)coverImageWithBookId:(NSString *)bookId;&#10;@end&#10;&#10;@protocol ReviewComponentProtocol &#60;NSObject&#62;&#10;- (UIViewController *)ReviewController:(NSString *)bookId;&#10;@end</span><br></pre></td></tr></table></figure></p>
<p>再在模块里实现这些接口，并在初始化时调用 registerProtocol 注册。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//BookDetailComponent  &#32452;&#20214;&#10;#import &#34;ProtocolMediator.h&#34;&#10;#import &#34;ComponentProtocol.h&#34;&#10;#import &#34;WRBookDetailViewController.h&#34;&#10;+ (void)initComponent&#10;&#123;&#10;   [[ProtocolMediator sharedInstance] registerProtocol:@protocol(BookDetailComponentProtocol) forClass:[self class];&#10;&#125;&#10;&#10;- (UIViewController *)bookDetailController:(NSString *)bookId &#123;&#10;    WRBookDetailViewController *detailVC = [[WRBookDetailViewController alloc] initWithBookId:param[@&#34;bookId&#34;]];&#10;    return detailVC;&#10;&#125;&#10;&#10;- (UIImage *)coverImageWithBookId:(NSString *)bookId &#123;&#10;    &#8230;.&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后调用者通过 protocol 从 ProtocolMediator 拿到提供这些方法的 Class，再进行调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//WRReadingViewController.m  &#35843;&#29992;&#32773;&#10;//ReadingViewController.m&#10;#import &#34;ProtocolMediator.h&#34;&#10;#import &#34;ComponentProtocol.h&#34;&#10;+ (void)gotoDetail:(NSString *)bookId &#123;&#10;    Class cls = [[ProtocolMediator sharedInstance] classForProtocol:BookDetailComponentProtocol];&#10;    id bookDetailComponent = [[cls alloc] init];&#10;    UIViewController *vc = [bookDetailComponent bookDetailController:bookId];&#10;    [self.navigationController pushViewController:vc animated:YES];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这种思路有点绕，这个方案跟刚才两个最大的不同就是，它不是直接通过 Mediator 调用组件方法，而是通过 Mediator 拿到组件对象，再自行去调用组件方法。</p>
<p>结果就是组件方法的调用是分散在各地的，没有统一的入口，也就没法做组件不存在时的统一处理。组件1调用了组件2的方法，如果用前面两种方式，组件间是没有依赖的，组件1+Mediator可以单独抽离出来，只需要在Mediator里做好调用组件2方法时的异常处理就行。而这种方法组件1对组件2的调用分散在各个地方，没法做这些处理，在不修改组件1代码的情况下，组件1和组件2是分不开的。</p>
<p>当然你也可以在这上面跟方案1一样在 Mediator 对每一个组件接口 wrapper 一层，那这样这种方案跟方案1比除了更复杂点，其他没什么区别。</p>
<p>在 protocol-class 这个方案上，主要存在的问题就是分散调用导致耦合，另外实现上会有一些绕，其他就没什么了。casa 说的 “protocol对业务产生了侵入，且不符合黑盒模型。” 其实并没有这么夸张，实际上 protocol 对外提供组件方法，跟方案1在 Mediator wrapper 对外提供组件方法是差不多的。</p>
<h2 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h2><p>蘑菇街在一个项目里同时用了方案2和方案3两种方式，会让写组件的人不知所措，新增一个接口时不知道该用方案2的方式还是方案3的方式，可能这个在蘑菇街内部会通过一些文档规则去规范，但其实是没有必要的。可能是蘑菇街作为电商平台一开始就注重APP页面间跳转的概念，每个模块已经有一个对应的URL，于是组件化时自然想到通过URL的方式表示组件，后续发现URL方式的限制，于是加上方案3的方式，这也是正常的探索过程。</p>
<p>上面论述下方案1确实比方案2+方案3简单明了，没有 注册表常驻内存/参数传递限制/调用分散 这些缺点，方案1多做的一步是需要对所有组件方法进行一层 wrapper，但若想要明确提供组件的方法和参数类型，解耦统一处理，方案2和方案3同样需要多加这层。</p>
<p>实际上我没有组件化相关的实践，这里仅从 limboy 和 casa 提供的这几个方案对比分析，我还对组件化带来的收益是否大于组件化增加的成本这点存疑，相信真正实践起来还会碰到很多坑，继续探索中。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/25/GYHttpMock/" itemprop="url">
                  GYHttpMock：iOS HTTP请求模拟工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-25T20:17:11+08:00" content="2016-02-25">
              2016-02-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <!--span class="post-meta-item-text">分类于</span-->
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <!--a href="/categories/hypo/" itemprop="url" rel="index"-->
                    <span itemprop="name">hypo</span>
                  <!--/a-->
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/25/GYHttpMock/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/25/GYHttpMock/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://github.com/hypoyao/GYHttpMock" target="_blank" rel="external">GYHttpMock</a> 是刚开源的 iOS 请求模拟工具，用于iOS App网络层开发，可以截获指定的 HTTP request，并根据规则，完全替换或部分修改真实的网络返回数据。</p>
<h2 id="u80CC_u666F"><a href="#u80CC_u666F" class="headerlink" title="背景"></a>背景</h2><p>iOS App开发过程中，前台开发过程通常都是并行进行的，因此难免会出现一些客户端需要等待后台开发联调的情景，等待的过程往往痛若而无奈（后台被催得痛苦，前端无奈等待）。通常解决办法是，客户端在某处 hardcode 网络返回数据，当然，一不小心，这种测试代码被提交到了线上也是常有的事情。还有更“高级”一点，通过设置代理，用抓包工具修改网络数据，但这种效率低得令人抓狂。</p>
<p>引入一个可以模拟网络请求的工具似乎就可以轻松满足需求，但实践证明，“模拟网络请求”这个需求并不简单。例如对于全新的业务，后台如果还没有数据，前端完全可以根据协议自己制造假数据返回。但是，很多情况下，可能是对已有业务的变更，也就是需要修改后台已有的业务数据。</p>
<h2 id="u4E1A_u754C_u89E3_u51B3_u65B9_u6848"><a href="#u4E1A_u754C_u89E3_u51B3_u65B9_u6848" class="headerlink" title="业界解决方案"></a>业界解决方案</h2><p>为了满足开发过程中模拟网络请求的需求，HttpMock 工具应运而生，目前业界已经有许多不同的实现方式，基本可以分为两类：</p>
<p><strong>1.自建HTTP Server</strong></p>
<p>可以在本地搭建 HTTP Server 模拟返回客户端所需要的数据。以 <a href="https://www.nuget.org/packages/HttpMock/" target="_blank" rel="external">hibri/HttpMock</a> 为例，它就是在本地搭建了一个HTTP Mock Server，然后根据需求返回指定数据。对于不需要模拟的请求，直接到达真实的Server，需要模拟的请求就转向MockServer。</p>
<p><img src="/./img/HttpMock2.png" alt=""></p>
<p>这种方案的优势在于可以应用于多平台，也可以用各种语言来实现。但是局限性在于，要建立一个 HTTP Server，一方面得自己搭建并维护这个 Server，对于使用者的门槛较高，另一方面，使用时需要一边修改客户端代码，一边切换到Server环境修改返回数据，比较麻烦。此外这种方案只能选择替换或不替换，无法做到替换某个请求返回的数据。</p>
<p><strong>2.客户端截获</strong></p>
<p>客户端可以在网络层截获自己的网络请求，然后返回指定数据。这种方式实现的 HttpMock 更加灵活，但是不同的客户端实现方式会完全不一样。实现原理是 Hook 系统网络层的请求分发，对于符合规则的 http request 进行拦截，然后用之前定义的数据直接回调给上层，并不发出真实的请求。</p>
<p><img src="/./img/HttpMock2.png" alt=""></p>
<p>iOS 上目前应用比较广泛的是<a href="https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="external">OHHTTPStubs</a>和<a href="https://github.com/luisobo/Nocilla" target="_blank" rel="external">Nocilla</a>，这两种实现的功能都类似。Nocilla选择用领域专用语言（DSL）的形式创建模拟请求，更容易理解，但是mock的功能需要应用中主动开启和关闭，一旦开启或关闭会影响应用中所有的HTTP请求。OHHTTPStubs 安装后自动启动，根据 request 自动判断是否需要截获。但目前这些开源库都未能做到灵活修改网络返回的数据。</p>
<h2 id="GYHttpMock__u4F18_u52BF"><a href="#GYHttpMock__u4F18_u52BF" class="headerlink" title="GYHttpMock 优势"></a>GYHttpMock 优势</h2><p><a href="http://github.com/hypoyao/GYHttpMock" target="_blank" rel="external">GYHttpMock</a> 采用客户端截获的方式，在 Nocilla DSL 特性基础上，同时学习OHHTTPStubs的自动开启和识别，实现了 http response 的部分替换功能。具体优势：</p>
<ul>
<li>支持部分替换 HTTP Response，也就是可以修改真实网络返回的数据，这是相对于其它 HttpMock 独有的核心功能。</li>
<li>客户端引入 GYHttpMock 后，只需一行代码就可以截获指定请求，并返回所需要的数据。不需服务端支持，也不需要建立本地HTTP Server。</li>
<li>支持 NSURLConnection， NSURLSession，AFNetworking 以及所有采用 iOS Cocoa URL 加载方式的网络框架。</li>
<li>支持正则匹配 HTTP Request，这样一条 httpMock 可以同时支持多个请求。</li>
<li>mocked response 支持 json 内容的文件。一般情况下，mocked response 直接用 NSString 表达会比较清晰，但是返回内容比较多的情况下，因为转义符的原因，将内容以 json 格式写入文件会更容易些。</li>
</ul>
<h2 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h2><h4 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h4><p>直接将 <a href="http://github.com/hypoyao/GYHttpMock" target="_blank" rel="external">GYHttpMock</a> 的源文件加入项目中即可。也可以通过 CocoaPods 的方式接入。</p>
<h4 id="u5E94_u7528"><a href="#u5E94_u7528" class="headerlink" title="应用"></a>应用</h4><p>在需要拦截的请求之前创建正确的mockRequest：</p>
<p>1.创建一个最简单的 mockRequest。截获应用中访问 www.weread.com 的 get 请求，并返回一个 response body为空的数据。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">mockRequest(<span class="string">@"GET"</span>, <span class="string">@"http://www.weread.com"</span>);</span><br></pre></td></tr></table></figure>
<p>2.创建一个拦截条件更复杂的 mockRequest。截获应用中 url 包含 weread.com，而且包含了 <code>name=abc</code> 的参数</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">mockRequest(<span class="string">@"GET"</span>, <span class="string">@"(.*?)weread.com(.*?)"</span><span class="variable">.regex</span>).</span><br><span class="line">    withBody(<span class="string">@"&#123;\"name\":\"abc\"&#125;"</span><span class="variable">.regex</span>);</span><br></pre></td></tr></table></figure>
<p>3.创建一个指定返回数据的 mockRequest。withBody的值也可以是某个 <code>xxx.json</code> 文件，不过这个 json 文件需要加入到项目中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">mockRequest(<span class="string">@"POST"</span>, <span class="string">@"http://www.weread.com"</span>).</span><br><span class="line">    withBody(<span class="string">@"&#123;\"name\":\"abc\"&#125;"</span><span class="variable">.regex</span>);</span><br><span class="line">    andReturn(<span class="number">200</span>).</span><br><span class="line">    withBody(<span class="string">@"&#123;\"key\":\"value\"&#125;"</span>);</span><br></pre></td></tr></table></figure>
<p>4.创建一个修改部分返回数据的 mockRequest。这里会根据 <code>weread.json</code> 的内容修改正常网络返回的数据</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">mockRequest(<span class="string">@"POST"</span>, <span class="string">@"http://www.weread.com"</span>).</span><br><span class="line">    isUpdatePartResponseBody(<span class="literal">YES</span>).</span><br><span class="line">    withBody(<span class="string">@"&#123;\"name\":\"abc\"&#125;"</span><span class="variable">.regex</span>);</span><br><span class="line">    andReturn(<span class="number">200</span>).</span><br><span class="line">    withBody(@“weread<span class="variable">.json</span><span class="string">");</span></span><br></pre></td></tr></table></figure>
<p> 假设正常网络返回的原始数据是这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;"<span class="attribute">data</span>": <span class="value">[ &#123;</span><br><span class="line">      "<span class="attribute">bookId</span>":<span class="value"><span class="string">"0000001"</span></span>,</span><br><span class="line">      "<span class="attribute">updated</span>": <span class="value">[</span><br><span class="line">        &#123;</span><br><span class="line">          "<span class="attribute">chapterIdx</span>": <span class="value"><span class="number">1</span></span>,</span><br><span class="line">          "<span class="attribute">title</span>": <span class="value"><span class="string">"序言"</span></span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "<span class="attribute">chapterIdx</span>": <span class="value"><span class="number">2</span></span>,</span><br><span class="line">          "<span class="attribute">title</span>": <span class="value"><span class="string">"第2章"</span></span>,</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line"></span>&#125;]</span>&#125;</span><br></pre></td></tr></table></figure>
<p>   <code>weread.json</code>的内容是这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;"<span class="attribute">data</span>": <span class="value">[&#123;</span><br><span class="line">      "<span class="attribute">updated</span>": <span class="value">[</span><br><span class="line">        &#123;</span><br><span class="line">           "<span class="attribute">hello</span>":<span class="value"><span class="string">"world"</span></span><br><span class="line">        </span>&#125;</span><br><span class="line">      ]</span><br><span class="line"></span>&#125;]</span>&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的数据就会就成这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;"<span class="attribute">data</span>": <span class="value">[ &#123;</span><br><span class="line">      "<span class="attribute">bookId</span>":<span class="value"><span class="string">"0000001"</span></span>,</span><br><span class="line">      "<span class="attribute">updated</span>": <span class="value">[</span><br><span class="line">        &#123;</span><br><span class="line">          "<span class="attribute">chapterIdx</span>": <span class="value"><span class="number">1</span></span>,</span><br><span class="line">          "<span class="attribute">title</span>": <span class="value"><span class="string">"序言"</span></span>,</span><br><span class="line">           "<span class="attribute">hello</span>":<span class="value"><span class="string">"world"</span></span><br><span class="line">        </span>&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "<span class="attribute">chapterIdx</span>": <span class="value"><span class="number">2</span></span>,</span><br><span class="line">          "<span class="attribute">title</span>": <span class="value"><span class="string">"第2章"</span></span>,</span><br><span class="line">          "<span class="attribute">hello</span>":<span class="value"><span class="string">"world"</span></span><br><span class="line">        </span>&#125;</span><br><span class="line">      ]</span><br><span class="line"></span>&#125;]</span>&#125;</span><br></pre></td></tr></table></figure>
<p>GYHttpMock会根据 <code>weread.json</code>指定的层次结构来修改原始数据，前提是 <code>wearied.json</code>的数据结构需要和正常的返回数据一致，否则会导致修改失败或者不可预知的错误。</p>
<h2 id="u5B9E_u73B0_u539F_u7406"><a href="#u5B9E_u73B0_u539F_u7406" class="headerlink" title="实现原理"></a>实现原理</h2><p>GYHttpMock的工作流程如下：<br><img src="/./img/HttpMock3.png" alt=""></p>
<p>其核心实现主要包括request匹配、request拦截、response替换三个部分。</p>
<h3 id="request_u5339_u914D"><a href="#request_u5339_u914D" class="headerlink" title="request匹配"></a>request匹配</h3><p>用于判断应用中的某个HTTP Request是否应该被mock。判断的条件包括method、URL、Headers、Body，其中URL和Body都支持正规匹配的方式，一个httpMock可以同时匹配多个HTTP Request。</p>
<h3 id="request_u62E6_u622A"><a href="#request_u62E6_u622A" class="headerlink" title="request拦截"></a>request拦截</h3><p>request拦截是通过继承<code>NSURLProtocol</code>的子类来实现。<code>NSURLProtocol</code>是iOS URL网络加载中功能非常强大的一个类,官方文档也有说明<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLProtocol_Class/" target="_blank" rel="external">NSURLProtocol</a>，通过重写它的方法，可以重新定义系统网络加载行为。在此之前，对于<code>NSURLConnection</code>的网络请求，需要这样注册<code>NSURLProtocol</code>的子类<code>GYMockURLProtocol</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSURLProtocol</span> registerClass:[GYMockURLProtocol class]];</span><br></pre></td></tr></table></figure>
<p>对于<code>NSURLSession</code>的网络请求，需要替换<code>protocolClasses</code>方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFURLSessionConfiguration"</span>) ?: <span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionConfiguration"</span>);</span><br><span class="line">[<span class="keyword">self</span> swizzleSelector:<span class="keyword">@selector</span>(protocolClasses) fromClass:cls toClass:[<span class="keyword">self</span> class]];</span><br></pre></td></tr></table></figure>
<p>最后，重点是重写<code>NSURLProtocol</code>类的<code>canInitWithRequest</code>和<code>startLoading</code>方法。<code>canInitWithRequest</code>是用于判断是否可以发起网络请求，可以通过这个过滤不在拦截范围内的request，不影响App的正常网络请求。<code>startLoading</code>是替换response数据的核心所在，成功截拦的request会进入该方法，在这个方法中替换或修改response数据，再回调给上层。</p>
<h3 id="response_u66FF_u6362"><a href="#response_u66FF_u6362" class="headerlink" title="response替换"></a>response替换</h3><p>对于需要全部替换的response，实现方式是在<code>startLoading</code>方法中调中<code>NSURLProtocol</code>的<code>URLProtocol:didReceiveResponse:cacheStoragePolicy:</code>方法，将替换好的response回调给上层。对于需要部分替换的response，GYHttpMock会用NSURLConnection的方式，发起一次真正的网络请求，待数据回来后，再与mockRequest中的response数据进行合并，最后将合并后的数据回调上层。部分替换过程中遇到两个问题:</p>
<ol>
<li><p>部分替换时要发出一个真实网络请求拿到原始数据，这个请求按照之前的规则又会被NSURLProtocol截获，从而进入死循环。解决办法是，start request前将这个GYHttpRequest打上标记，表明是不需要再次截获的，等拿到reponse后再将GYHttpRequest上的标记去掉，避免死循环。</p>
</li>
<li><p>两个response内容合并的问题。因为json的数据结构非常灵活，可以任意层次嵌套，如何指定修改或添加某个节点下的数据是比较困难的，尤其是json中数组的嵌套，导致要指定修改数组中某个位置的元素变得非常困难。GYHttpMock采用的方式是，在mockRequest的response中指出需要修改的节点完整位置，然后用这个数据结构去匹配目标数据（具体算法请查看<a href="http://github.com/hypoyao/GYHttpMock" target="_blank" rel="external">GYHttpMock源码</a>，好处在于可以支持比较复杂的数据结构，但这就要求使用者对目标数据结构非常清楚。</p>
</li>
</ol>
<p>GYHttpMock已经在<a href="http://github.com/hypoyao/GYHttpMock" target="_blank" rel="external">GitHub</a>开源，目前已用于<a href="http://weread.qq.com" target="_blank" rel="external">微信读书</a>项目中，使用过程如果有问题或者建议，欢迎提交 issue 和 pull request。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/22/MLeaksFinder/" itemprop="url">
                  MLeaksFinder：精准 iOS 内存泄露检测工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-22T11:45:13+08:00" content="2016-02-22">
              2016-02-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <!--span class="post-meta-item-text">分类于</span-->
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <!--a href="/categories/zepo/" itemprop="url" rel="index"-->
                    <span itemprop="name">zepo</span>
                  <!--/a-->
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/22/MLeaksFinder/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/22/MLeaksFinder/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u80CC_u666F"><a href="#u80CC_u666F" class="headerlink" title="背景"></a>背景</h1><p>平常我们都会用 Instrument 的 Leaks / Allocations 或其他一些开源库进行内存泄露的排查，但它们都存在各种问题和不便，我们逐个来看这些工具的使用和存在的问题。</p>
<h3 id="Leaks"><a href="#Leaks" class="headerlink" title="Leaks"></a>Leaks</h3><p>先看看 Leaks，从苹果的开发者文档里可以看到，一个 app 的内存分三类：</p>
<ul>
<li><p><strong>Leaked memory</strong>: Memory unreferenced by your application that cannot be used again or freed (also detectable by using the Leaks instrument).</p>
</li>
<li><p><strong>Abandoned memory</strong>: Memory still referenced by your application that has no useful purpose.</p>
</li>
<li><p><strong>Cached memory</strong>: Memory still referenced by your application that might be used again for better performance.</p>
</li>
</ul>
<p>其中 Leaked memory 和 Abandoned memory 都属于应该释放而没释放的内存，都是内存泄露，而 Leaks 工具只负责检测 Leaked memory，而不管 Abandoned memory。在 MRC 时代 Leaked memory 很常见，因为很容易忘了调用 release，但在 ARC 时代更常见的内存泄露是循环引用导致的 Abandoned memory，Leaks 工具查不出这类内存泄露，应用有限。</p>
<h3 id="Allocations"><a href="#Allocations" class="headerlink" title="Allocations"></a>Allocations</h3><p>对于 Abandoned memory，可以用 Instrument 的 Allocations 检测出来。检测方法是用 Mark Generation 的方式，当你每次点击 Mark Generation 时，Allocations 会生成当前 App 的内存快照，而且 Allocations 会记录从上回内存快照到这次内存快照这个时间段内，新分配的内存信息。举一个最简单的例子：</p>
<p>我们可以不断重复 push 和 pop 同一个 UIViewController，理论上来说，push 之前跟 pop 之后，app 会回到相同的状态。因此，在 push 过程中新分配的内存，在 pop 之后应该被 dealloc 掉，除了前几次 push 可能有预热数据和 cache 数据的情况。如果在数次 push 跟 pop 之后，内存还不断增长，则有内存泄露。因此，我们在每回 push 之前跟 pop 之后，都 Mark Generation 一下，以此观察内存是不是无限制增长。这个方法在 WWDC 的视频里：<a href="http://developer.apple.com/videos/wwdc/2010/" target="_blank" rel="external">Session 311 - Advanced Memory Analysis with Instruments</a>，以及苹果的开发者文档：<a href="https://developer.apple.com/library/mac/recipes/Instruments_help_articles/FindingAbandonedMemory/FindingAbandonedMemory.html" target="_blank" rel="external">Finding Abandoned Memory</a> 里有介绍。</p>
<p>用这种方法来发现内存泄露还是很不方便的：</p>
<ul>
<li>首先，你得打开 Allocations</li>
<li>其次，你得一个个场景去重复的操作</li>
<li>无法及时得知泄露，得专门做一遍上述操作，十分繁琐</li>
</ul>
<h3 id="u5F00_u6E90_u5E93"><a href="#u5F00_u6E90_u5E93" class="headerlink" title="开源库"></a>开源库</h3><p>在 GitHub 上有一些内存泄露检测相关的项目，例如 <a href="https://github.com/tapwork/HeapInspector-for-iOS" target="_blank" rel="external">HeapInspector-for-iOS</a> 和 <a href="https://github.com/mindsnacks/MSLeakHunter" target="_blank" rel="external">MSLeakHunter</a>。</p>
<p>HeapInspector-for-iOS 可以说是 Allocations 的改进。它通过 hook 掉 alloc，dealloc，retain，release 等方法，来记录对象的生命周期。具体的检测内存泄露的方法和原理，与 Instrument 的 Allocations 一致。然而它跟 Allocations 一样，存在的问题是，你需要一个个场景去重复的操作，还有检测不及时。</p>
<p>MSLeakHunter 就简单得多，它只检测 UIViewController 和 UIView，通过 hook 掉 UIViewController 的 <code>-viewDidDisappear:</code> 方法，并认为 <code>-viewDidDisappear:</code> 后，UIViewController 将很快被释放，如果 UIViewController 没有被释放，则打个建议日志。这种做法其实不是很好，<code>-viewDidDisappear:</code> 被调用可能是因为又 push 进来一个新的 ViewController，把当前的 ViewController 挡住了，所以可能有很多错误的建议，需要结合你实际的操作去具体地分析日志。</p>
<h1 id="MLeaksFinder"><a href="#MLeaksFinder" class="headerlink" title="MLeaksFinder"></a>MLeaksFinder</h1><p><a href="https://github.com/Zepo/MLeaksFinder" target="_blank" rel="external">MLeaksFinder</a> 提供了内存泄露检测更好的解决方案。只需要引入 MLeaksFinder，就可以自动在 App 运行过程检测到内存泄露的对象并立即提醒，无需打开额外的工具，也无需为了检测内存泄露而一个个场景去重复地操作。MLeaksFinder 目前能自动检测 UIViewController 和 UIView 对象的内存泄露，而且也可以扩展以检测其它类型的对象。</p>
<p>MLeaksFinder 的使用很简单，参照 <a href="https://github.com/Zepo/MLeaksFinder" target="_blank" rel="external">https://github.com/Zepo/MLeaksFinder</a>，基本上就是把 MLeaksFinder 目录下的文件添加到你的项目中，就可以在运行时（debug 模式下）帮助你检测项目里的内存泄露了，无需修改任何业务逻辑代码，而且只在 debug 下开启，完全不影响你的 release 包。</p>
<p>当发生内存泄露时，MLeaksFinder 会中断言，并准确的告诉你哪个对象泄露了。这里设计为中断言而不是打日志让程序继续跑，是因为很多人不会去看日志，断言则能强制开发者注意到并去修改，而不是犯拖延症。</p>
<p>中断言时，控制台会有如下提示，View-ViewController stack 从上往下看，该 stack 告诉你，MyTableViewController 的 UITableView 的 subview UITableViewWrapperView 的 subview MyTableViewCell 没被释放。而且，这里我们可以肯定的是 MyTableViewController，UITableView，UITableViewWrapperView 这三个已经成功释放了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Possibly Memory Leak.</span><br><span class="line">In case that MyTableViewCell should not be dealloced, override -willDealloc in MyTableViewCell by returning NO.</span><br><span class="line">View-ViewController stack: (</span><br><span class="line">    MyTableViewController,</span><br><span class="line">    UITableView,</span><br><span class="line">    UITableViewWrapperView,</span><br><span class="line">    MyTableViewCell</span><br><span class="line">)'</span><br></pre></td></tr></table></figure>
<p>从 MLeaksFinder 的使用方法可以看出，MLeaksFinder 具备以下优点：</p>
<ul>
<li>使用简单，不侵入业务逻辑代码，不用打开 Instrument</li>
<li>不需要额外的操作，你只需开发你的业务逻辑，在你运行调试时就能帮你检测</li>
<li>内存泄露发现及时，更改完代码后一运行即能发现（这点很重要，你马上就能意识到哪里写错了）</li>
<li>精准，能准确地告诉你哪个对象没被释放</li>
</ul>
<h1 id="u539F_u7406"><a href="#u539F_u7406" class="headerlink" title="原理"></a>原理</h1><p>MLeaksFinder 一开始从 UIViewController 入手。我们知道，当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。</p>
<p>具体的方法是，为基类 NSObject 添加一个方法 <code>-willDealloc</code> 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 <code>-assertNotDealloc</code>，而 <code>-assertNotDealloc</code> 主要作用是直接中断言。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)willDealloc &#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [weakSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)assertNotDealloc &#123;</span><br><span class="line">     <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, @“”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当我们认为某个对象应该要被释放了，在释放前调用这个方法，如果3秒后它被释放成功，weakSelf 就指向 nil，不会调用到 <code>-assertNotDealloc</code> 方法，也就不会中断言，如果它没被释放（泄露了），<code>-assertNotDealloc</code> 就会被调用中断言。这样，当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 <code>-willDealloc</code>，若3秒后没被释放，就会中断言。</p>
<p>在这里，有几个问题需要解决：</p>
<ol>
<li><p>不入侵开发代码</p>
<p>这里使用了 AOP 技术，hook 掉 UIViewController 和 UINavigationController 的 pop 跟 dismiss 方法，关于如何 hook，请参考 <a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a>。</p>
</li>
<li><p>遍历相关对象</p>
<p>在实际项目中，我们发现有时候一个 UIViewController 被释放了，但它的 view 没被释放，或者一个 UIView 被释放了，但它的某个 subview 没被释放。这种内存泄露的情况很常见，因此，我们有必要遍历基于 UIViewController 的整棵 View-ViewController 树。我们通过 UIViewController 的 presentedViewController 和 view 属性，UIView 的 subviews 属性等递归遍历。对于某些 ViewController，如 UINavigationController，UISplitViewController 等，我们还需要遍历 viewControllers 属性。</p>
</li>
<li><p>构建堆栈信息</p>
<p>需要构建 View-ViewController stack 信息以告诉开发者是哪个对象没被释放。在递归遍历 View-ViewController 树时，子节点的 stack 信息由父节点的 stack 信息加上子结点信息即可。</p>
</li>
<li><p>例外机制</p>
<p>对于有些 ViewController，在被 pop 或 dismiss 后，不会被释放（比如单例），因此需要提供机制让开发者指定哪个对象不会被释放，这里可以通过重载上面的 <code>-willDealloc</code> 方法，直接 return NO 即可。</p>
</li>
<li><p>特殊情况</p>
<p>对于某些特殊情况，释放的时机不大一样（比如系统手势返回时，在划到一半时 hold 住，虽然已被 pop，但这时还不会被释放，ViewController 要等到完全 disappear 后才释放），需要做特殊处理，具体的特殊处理视具体情况而定。</p>
</li>
<li><p>系统View</p>
<p>某些系统的私有 View，不会被释放（可能是系统 bug 或者是系统出于某些原因故意这样做的，这里就不去深究了），因此需要建立白名单</p>
</li>
<li><p>手动扩展</p>
<p>MLeaksFinder目前只检测 ViewController 跟 View 对象。为此，MLeaksFinder 提供了一个手动扩展的机制，你可以从 UIViewController 跟 UIView 出发，去检测其它类型的对象的内存泄露。如下所示，我们可以检测 UIViewController 底下的 View Model：</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MLCheck(<span class="keyword">self</span><span class="variable">.viewModel</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的原理跟上面的是一样的，宏 MLCheck() 做的事就是为传进来的对象建立 View-ViewController stack 信息，并对传进来的对象调用 <code>-willDealloc</code> 方法。</p>
<h1 id="u672A_u6765"><a href="#u672A_u6765" class="headerlink" title="未来"></a>未来</h1><p>MLeaksFinder 目前还在起步阶段，它的内存泄露检测的想法是很简单，很直接的。虽然目前只能自动地检测 UIViewController 和 UIView 相关的对象，然而在我们几个大的项目中，已经起到很大的作用，帮助我们发现很多历史存在的内存泄露，而且确保新提交的 UI 相关代码不会引进新的问题。MLeaksFinder 会继续探索覆盖更广的情况，提供更全面的检测，包括网络层，数据存储层等等。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.png"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        
        <div class="links">
          <h4>开源项目</h4>
          <div class="links-of-author motion-element">
            
              
                <div class="links-of-author-item">
                  <a href="https://github.com/bang590/JSPatch" target="_blank">
                    
                      <i class="fa fa-github"></i> JSPatch
                    
                  </a>
                </div>
              
                <div class="links-of-author-item">
                  <a href="https://github.com/Zepo/MLeaksFinder" target="_blank">
                    
                      <i class="fa fa-globe"></i> MLeaksFinder
                    
                  </a>
                </div>
              
                <div class="links-of-author-item">
                  <a href="https://github.com/hypoyao/GYHttpMock" target="_blank">
                    
                      <i class="fa fa-github"></i> GYHttpMock
                    
                  </a>
                </div>
              
            
          </div>
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>

<div class="powered-by">
  程序 - <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="footer-links">
  <a href="http://weread.qq.com/">
    微信读书
  </a>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1895639-12', 'auto');
  ga('send', 'pageview');

</script>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'wereadteam';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  

  
  


</body>
</html>
